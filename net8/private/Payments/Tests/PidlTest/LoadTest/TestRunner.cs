// <copyright file="TestRunner.cs" company="Microsoft">Copyright (c) Microsoft 2016. All rights reserved.</copyright>
namespace PidlTest.Load
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Diagnostics;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Security.Cryptography;
    using System.Text;
    using System.Threading.Tasks;

    // parsable options [/Env (PPE, PROD) /Mode (alert) /Acc (email) (password) /help /?]
    // Sample usage
    // Run Load Test by: PidlTest.exe /TestType LoadTest /Env PPE /Acc mstest_paayments_emaail1501@outlook.com yourpassword
    internal class TestRunner : ITestRunner
    {
        #region Constants
        // Command line arguments supported by this test
        private const string ArgEnv = "/Env";
        private const string ArgAcc = "/Acc";
        private const string ArgMode = "/Mode";

        // User information used in load test
        private const string UserInfo = "users/me/";

        // alert mode input value
        private const string AlertMode = "alert";

        // TokenWrapper
        private const string TokenWrapper = "WLID1.0=\"{0}\"";

        // Number of sockets
        private const int MaxSockets = 20;

        // Keep-alive duration in milliseconds
        private const int KeepAliveDuration = 1000;

        // Time interval (in ms) between batches of requests being created
        private const int BatchInterval = 1000;

        // Time interval (in ms) between monitoring of responses
        private const int MonitorInterval = 40;

        // Time interval (in ms) between printing aggregated results
        private const int PrintInterval = 200;

        // This test creates requests at a rate that matches the rate at which transactions are being
        // completed. If it creates less, then, we are not maximizing the load that can generate but
        // on the other hand, if it creates requests at a higher rate, the pending requests will grow
        // indefinitely until we run out of memory / connections etc. To maintain this equilibrium,
        // the number of pending requests is maintained at a healty number. Below is the set point.
        private const long PendingRequestsSetPoint = 1000;

        // When the actual number of pending requests deviates from the setpoint, the rate of requests
        // being created is incremented / decremented by this amount every batch interval
        private const double Trim = 1;
        #endregion

        #region Member Variables
        // Base address of the server to run this test against
        private string baseAddress = string.Empty;

        // The number of pending requests at the most recent snapshot (a snapshot is taken every monitorInterval 
        // milliseconds)
        private long pendingRequests = 0;

        // The number of pending requests at the previous-to-most-recent snapshot (a snapshot is taken every 
        // monitorInterval milliseconds)
        private long prevPendingRequests = 0;

        // This is the number of requests that will be created in every batch. The value of this will be adjusted as the
        // test runs to create the most load possible without causing the pending requests to keep increasing beyond the 
        // pendingRequestsSetPoint.
        private double requestsPerBatch = 2.0;

        // Instance of HttpClient used to send all requests for this test
        private HttpClient pidlClient = new HttpClient();

        // A list containing HttpTransaction tasks that have not completed and processed yet
        private List<Task<LoadTestRequestResponse>> activeTasks = new List<Task<LoadTestRequestResponse>>();

        private List<Task<LoadTestRequestResponse>> inactiveTasks = new List<Task<LoadTestRequestResponse>>();

        // A flag that controls the Start/Stop status of this test
        private bool runTest = false;

        // Testing environment
        private string environment = string.Empty;

        // Testing environment type
        private EnvironmentType environmentType;

        // Username and passord for testing account
        private string username = string.Empty;
        private string password = string.Empty;

        // Load testing mode
        private string mode = string.Empty;

        // AuthToken generated by the input username and password
        private string authToken = string.Empty;

        // Number of different types of http response
        private int total200RespCount = 0;
        private int total300RespCount = 0;
        private int total400RespCount = 0;
        private int total500RespCount = 0;
        private int totalRespCount = 0;

        // Mode of load test
        private bool isAlertMode = false;
        #endregion

        // Valid testing enviroment type of load test
        private enum EnvironmentType
        {
            PPE,
            Prod
        }

        public async Task<int> StartTestAsync()
        {
            this.runTest = true;
            ServicePointManager.DefaultConnectionLimit = MaxSockets;
            ServicePointManager.MaxServicePointIdleTime = KeepAliveDuration;
            this.pidlClient.BaseAddress = new Uri(this.baseAddress);
            this.pidlClient.DefaultRequestHeaders.TryAddWithoutValidation("Authorization", this.authToken);
            Task load = Task.Run(() => this.GenerateLoadAsync());
            Task monitor = Task.Run(() => this.MonitorResultsAsync());

            await Task.WhenAll(new Task[]
            {
                load, monitor
            });

            return 0;
        }

        public async Task StopTestAsync()
        {
            this.runTest = false;
            await Task.FromResult<object>(null);
        }

        public bool ParseArguments(string[] args)
        {
            for (int i = 0; i < args.Length; i++)
            {
                if (string.Compare(args[i], ArgEnv, true) == 0)
                {
                    if (i + 1 >= args.Length)
                    {
                        Console.WriteLine(Constants.ErrorMessages.ArgValueMissingFormat, ArgEnv);
                        return false;
                    }
                    else
                    {
                        this.environment = args[i + 1];
                    }
                }
                else if (string.Compare(args[i], ArgAcc, true) == 0)
                {
                    if (i + 1 >= args.Length)
                    {
                        Console.WriteLine(Constants.ErrorMessages.ArgValueMissingFormat, ArgAcc);
                        return false;
                    }
                    else
                    {
                        this.username = args[i + 1];
                        this.password = args[i + 2];
                    }
                }
                else if (string.Compare(args[i], ArgMode, true) == 0)
                {
                    if (i + 1 >= args.Length)
                    {
                        Console.WriteLine(Constants.ErrorMessages.ArgValueMissingFormat, ArgMode);
                        return false;
                    }
                    else
                    {
                        this.mode = args[i + 1];
                    }
                }
                else if (string.Compare(args[i], "/?", true) == 0 || string.Compare(args[i], "/help", true) == 0)
                {
                    ShowHelp();
                    return false;
                }
            }

            if (this.mode.Equals(AlertMode, StringComparison.InvariantCultureIgnoreCase))
            {
                this.isAlertMode = true;
            }

            if (string.IsNullOrEmpty(this.environment))
            {
                Console.WriteLine(Constants.ErrorMessages.ArgMissingFormat, ArgEnv);
                return false;
            }

            if (!Enum.TryParse(this.environment, out this.environmentType))
            {
                Console.WriteLine("Environment {0} is not PPE, PROD", this.environment);
                return false;
            }

            switch (this.environmentType)
            {
                case EnvironmentType.PPE:
                    this.baseAddress = Constants.Environment.PPE + UserInfo;

                    if (string.IsNullOrEmpty(this.username) || string.IsNullOrEmpty(this.password))
                    {
                        this.username = AppConfig.Configuration["PPE_Email"];
                        this.password = AppConfig.Configuration["PPE_Password"];
                    }

                    break;
                case EnvironmentType.Prod:
                    this.baseAddress = Constants.Environment.Prod + UserInfo;

                    if (string.IsNullOrEmpty(this.username) || string.IsNullOrEmpty(this.password))
                    {
                        this.username = AppConfig.Configuration["PROD_Email"];
                        this.password = AppConfig.Configuration["PROD_Password"];
                    }

                    break;
                default:
                    Console.WriteLine("Environment {0} is not PPE, PROD", this.environment);
                    return false;
            }

            Console.Write("Generate token...");
            try
            {
                var token = Generator.GenerateAsync(this.environmentType.ToString().ToLower(), this.username, this.password).Result;

               this.authToken = string.Format(TokenWrapper, token);
                Console.WriteLine("DONE");
            }
            catch (Exception e)
            {
                Console.WriteLine("Failed to generate token");
                Console.WriteLine(e.Message);
                Console.Write(e.StackTrace);
                return false;
            }

            return true;
        }

        public async Task GenerateLoadAsync()
        {
            // Runs one iteration per batch until the test is stopped
            while (this.runTest)
            {
                long rateOfChange = this.pendingRequests - this.prevPendingRequests;
                long delta = this.pendingRequests - PendingRequestsSetPoint;
                if (delta > 0 && rateOfChange > 0)
                {
                    this.requestsPerBatch -= Trim;
                }
                else if (delta < 0 && rateOfChange < 0)
                {
                    this.requestsPerBatch += Trim;
                }

                for (int i = 0; i < this.requestsPerBatch; i++)
                {
                    Task<LoadTestRequestResponse> getRequestResponseTask = Task.Run(() => this.GetRequestResponseAsync());
                    lock (this)
                    {
                        this.activeTasks.Add(getRequestResponseTask);
                    }
                }

                await Task.Delay(BatchInterval);
            }
        }

        public async Task MonitorResultsAsync()
        {
            Stopwatch printWatch = new Stopwatch();
            printWatch.Start();

            // Even after runTest is set to false, this loop may have to run for a few extra seconds to 
            // drain out all pending Tasks.
            while (this.runTest || this.pendingRequests > 0)
            {
                await Task.Delay(MonitorInterval);

                lock (this)
                {
                    this.inactiveTasks.AddRange(this.activeTasks.Where(x => (x.IsCanceled || x.IsFaulted || x.IsCompleted)));
                    this.activeTasks.RemoveAll(x => x.IsCanceled || x.IsFaulted || x.IsCompleted);
                    this.prevPendingRequests = this.pendingRequests;
                    this.pendingRequests = this.activeTasks.Count;
                }

                if (printWatch.ElapsedMilliseconds > PrintInterval)
                {
                    this.PrintStats(printWatch.ElapsedMilliseconds);
                    printWatch.Restart();
                }
            }
        }

        private static void ShowHelp()
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.Append("--------------------------------------------------------------------------------------------------------------");
            stringBuilder.Append("PIDLTest.exe /TestType LoadTest /Env <PPE, PROD> /Acc <email> <password> /Mode <alert, or left empty for default normal mode> /help /?");
            stringBuilder.Append(string.Empty);
            stringBuilder.Append("  /Env    - Environment name of PX that the load test is perfromed against.  Values can be PPE or PROD");
            stringBuilder.Append("  /Acc    - Email and password of account that is being tested. Ensure the account matches the specified test environment");
            stringBuilder.Append("  /Mode   - Optinal. The mode of load test. If left empty value default normal mode is selected. If input value is alert, then alert mode will be trigged which includes 500 responses on purpuse.");
            stringBuilder.Append(string.Empty);
            stringBuilder.Append("Examples:");
            stringBuilder.Append("PidlTest.exe /TestType LoadTest /Env PPE /Acc mstest_paayments_emaail1501@outlook.com Q5k5XYrDYus7gggT");
            stringBuilder.Append("--------------------------------------------------------------------------------------------------------------");

            Console.WriteLine(stringBuilder.ToString());
        }

        private static int GetRandomNumber(int minValue, int maxValue)
        {
            if (minValue >= maxValue)
            {
                return minValue;
            }

            int randomNumber;
            using (RNGCryptoServiceProvider randomProvider = new RNGCryptoServiceProvider())
            {
                byte[] randomData = new byte[1];
                int range = maxValue - minValue + 1;
                do
                {
                    randomProvider.GetBytes(randomData);
                }
                while (!IsFairNumber(randomData[0], range));

                int randomRange = Convert.ToInt32(randomData[0]) % range;
                randomNumber = randomRange + minValue;
            }

            return randomNumber;
        }

        private static bool IsFairNumber(byte randomNumber, int range)
        {
            int fullSetsOfValues = byte.MaxValue / range;
            return randomNumber < range * fullSetsOfValues;
        }

        private async Task<LoadTestRequestResponse> GetRequestResponseAsync()
        {
            string testUrl = string.Empty;

            if (this.isAlertMode)
            {
                // Get a random index to pick one of the test urls.
                int urlIndex = GetRandomNumber(0, Constants.LoadTest.TestUrlsTriggerFiveHundredResponse.Length - 1);
                testUrl = Constants.LoadTest.TestUrlsTriggerFiveHundredResponse[urlIndex];
            }
            else
            {
                int urlIndex = GetRandomNumber(0, Constants.LoadTest.TestUrlsTriggerTwoHundredResponse.Length - 1);
                testUrl = Constants.LoadTest.TestUrlsTriggerTwoHundredResponse[urlIndex];
            }

            LoadTestRequestResponse requestResponse = new LoadTestRequestResponse();

            Stopwatch watch1 = new Stopwatch();
            watch1.Start();
            HttpResponseMessage responseMessage = await this.pidlClient.GetAsync(testUrl);
            watch1.Stop();

            int statusCode = (int)responseMessage.StatusCode;
            lock (this)
            {
                this.totalRespCount += 1;
                if (statusCode >= 200 && statusCode < 300)
                {
                    this.total200RespCount += 1;
                }
                else if (statusCode >= 300 && statusCode < 400)
                {
                    this.total300RespCount += 1;
                }
                else if (statusCode >= 400 && statusCode < 500)
                {
                    this.total400RespCount += 1;
                }
                else if (statusCode >= 500)
                {
                    this.total500RespCount += 1;
                }
            }

            requestResponse.ResponseTime = watch1.ElapsedMilliseconds;

            return requestResponse;
        }

        private void PrintStats(long totalElapsedTime)
        {
            Console.Clear();
            long totalCompletedRequests = this.inactiveTasks.Where(s => s.IsCompleted).Count();
            long totalOfResponseTimes = this.inactiveTasks.Where(s => s.IsCompleted).Sum(s => s.Result.ResponseTime);

            Console.WriteLine("Requests Pending     : {0}", this.pendingRequests);
            Console.WriteLine("Requests/Batch       : {0}", this.requestsPerBatch);
            Console.WriteLine("Requests Completed   : {0}", totalCompletedRequests);
            Console.WriteLine("Average Response ms  : {0}", totalCompletedRequests == 0 ? "NAN" : (totalOfResponseTimes / totalCompletedRequests).ToString());
            Console.WriteLine("Transactions/Second  : {0}", 1000 * totalCompletedRequests / totalElapsedTime);
            Console.WriteLine("Total responses received : {0}", this.totalRespCount);
            Console.WriteLine("200 responses percentage : {0:0.0%}", this.totalRespCount == 0 ? 0 : (this.total200RespCount * 1.0 / this.totalRespCount));
            Console.WriteLine("300 responses percentage : {0:0.0%}", this.totalRespCount == 0 ? 0 : (this.total300RespCount * 1.0 / this.totalRespCount));
            Console.WriteLine("400 responses percentage : {0:0.0%}", this.totalRespCount == 0 ? 0 : (this.total400RespCount * 1.0 / this.totalRespCount));
            Console.WriteLine("500 responses percentage : {0:0.0%}", this.totalRespCount == 0 ? 0 : (this.total500RespCount * 1.0 / this.totalRespCount));
            if (this.runTest == false)
            {
                Console.WriteLine("Stopping...");
            }

            this.inactiveTasks.Clear();
        }
    }
}
